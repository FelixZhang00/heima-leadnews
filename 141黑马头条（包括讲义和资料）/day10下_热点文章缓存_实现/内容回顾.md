**出现分布式锁问题的场景**

```
评论点赞功能:   
 
   使用jmeter 压力测试工具测试接口
   		
   		创建线程组 : 可以模拟大量的线程访问我们的微服务接口   (2000线程   1s    1次)
   		
   		创建取样器 :  http请求   参数: 点赞接口的参数
   		
   		配置请求头 :  设置content-type  json    userId 登录用户id
   		
   		配置结果监听 : 获取访问结果的
   		              结果树 :  请求是否成功，和请求参数 响应内容
                      
                      聚合报告 :  性能测试
       
  测试结果:
       点赞表:  数据正常加入
       
       评论表:  点赞数量计算错误
       
  产生原因:  分布式架构种 对于共享资源，没有控制其  同步访问
   		              
   		              
```

**如何实现分布式锁**

```
1.  基于数据库  行锁
       select  for update:
       
       特点:  加锁简单，好理解
       
       缺点:  性能差

2.  基于zookeeper实现  ( 文件系统 (持久  持久顺序   临时   临时顺序)           watch监听机制)

	   实现:   1.  多个客户端，同时尝试 创建指定目录节点，  哪个客户端创建成功，说明得到锁
	              没得锁的客户端，通过watch 监听所指定目录节点， 拿到锁客户端执行代码完毕后，删除指定节点，  其它收到通知  继续获取锁
	              
	              缺点:  惊群效应， 高并发时会出现多个客户端同时监听节点，释放时需要通知多个节点，影响zookeeper的性能
	            
	           2.  多个客户端，同时创建 临时 有序的目录节点
	           				lock00001
	           				
	           				lock00002
	           				
	           				lock00003
	           				
	           		顺序编号小的获取到锁，先执行
	           		
	           		未获取到锁的客户端，只监听上一个编号的目录节点
	           		
	           		当锁释放时， 只有下一编号的客户端收到通知
	           		
	           		性能比较好，且实现了有序性
	   特点:  一致性
	   
	   缺点:  和redis比性能弱一些,实现更复杂些
	   
	   
3. 基于redis实现  （通过  apache Redisson框架  ）
	
	高可用分布式锁需要满足的特点:
	   互斥性
	   
	   可重入
	   
	   锁超时
	   
	   锁的自动续约
	   
	   公平 和 非公平
	   
	   阻塞 非 非阻塞
	   
	   高可用
	   
	redisson加锁的原理:  
	
	主要基于Lua脚本 (Lua脚本可以保证多个redis命令的原子性)
	
	1. 通过lua脚本加锁:   
	
	     判断指定锁key是否存在
	         如果不存在:
	            通过hash结构加锁:   hset   锁名称   客户端id(UUID+线程id)   锁的次数
	         	设置失效时间:  默认30s
	         如果存在:
	            判断是否是当前客户端加的锁
	                 如果是  在锁的次数上加1    执行重入锁
	                 
	                 如果不是  直接返回剩余的失效时间
	             
	2. 加锁成功后，会开启一个后台调度线程，调度线程每隔10s执行一次   (watch dog  看门狗)
	   重置当前客户端的锁的失效时间  作用实现了 锁的自动续约
	   
	
	3. 通过lua脚本解锁
	
	     判断锁key是否存在
	     
	     如果存在, 判断是否是当前客户端加的锁
	     
	     
	     如果是，将锁的  次数 -1
	     
	     判断 剩余次数 是否大于0
	     
	         如果大于0   说明未完全解锁   重置失效时间并返回
	         
	         
	         如果小于等于0  说明完全解锁   删除锁的key    del  key
	         

   代码使用:   
    1. 引入redisson依赖
    
    2.  配置 RedissonClient客户端
    
    3. 加锁解锁:   
           获取锁对象   client.getLock()     getFairLock()
           
           加锁      lock.lock()     lock.tryLock()
           
           解锁      finnally   lock.unlock()
	             
```



**分布式任务调度框架xxljob**

```
调度中心   (springboot web项目  需要单独部署   准备好数据库)

	作用:  提供了可视化的页面，统一的管理定时任务
	
	日志管理: 查看任务的执行日志
	
	执行器:  可以创建执行器列表   自动注册   手动注册
			
	任务管理:   
		 cron：  时间表达式    
		         秒   分   时   天   月   星期   年
		         
		         *  任意的时间
		         -  范围
		         ,  多个
		         /  间隔
		         L  最后  
		         #  第几个周几   6#3
		         W  最近的工作日
		         ?  不确定的时间   天       星期
        路由策略:   轮询
                  第一个   最后一个
                  随机
                 
                  分片广播   (当前执行器下标   执行器总个数)

		阻塞策略:  串行    丢弃后面的    覆盖前面
微服务配置xxljob
	
	引入 xxljob的依赖
	
	修改配置文件:   
			调度中心的地址
			
			执行器的名称
			
			当前执行器的IP和PORT  或 配置  address
    配置执行器Bean :
    		
	配置任务实现:   
          @XxlJob("任务的名称")
          public ReturnT  handler(String params){
              
              // 任务处理方法
          }
		
```





